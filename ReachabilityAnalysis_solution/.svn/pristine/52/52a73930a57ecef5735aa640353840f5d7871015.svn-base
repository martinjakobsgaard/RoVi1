/*
 * PickAndPlaceSimulator.h
 *
 *  Created on: Nov 1, 2017
 *      Author: Simon Mathiesen
 */
#ifndef PICKANDPLACESIMULATOR_H_
#define PICKANDPLACESIMULATOR_H_

#include <rwsim/rwsim.hpp>
#include <rwsimlibs/ode/ODESimulator.hpp>
#include <rw/loaders.hpp>
#include <rw/models.hpp>
#include <rw/RobWork.hpp>
#include <rw/kinematics.hpp>
#include <rwlibs/proximitystrategies/ProximityStrategyFactory.hpp>
#include <rw/trajectory/BlendedTrajectory.hpp>
#include <rws/RobWorkStudio.hpp>


USE_ROBWORK_NAMESPACE
using namespace std;
using namespace robwork;
using namespace rw;
using namespace rw::common;
using namespace rw::proximity;
using namespace rw::math;

using namespace rwsim::contacts;
using namespace rwsim::dynamics;
using namespace rwsim::loaders;
using namespace rwsim::simulator;

class PickAndPlaceSimulator {
public:
   //! @brief smart pointer type of this class
	typedef rw::common::Ptr<PickAndPlaceSimulator> Ptr;

	PickAndPlaceSimulator(
			rw::common::Ptr<DynamicWorkCell> dwc,
			const std::string &engineID,
			double dt,
			bool debug);

	virtual ~PickAndPlaceSimulator();
	void initialise(State& state, TimedStatePath& tStatePath, double runTime=1);
	void simulateGripper(State& state, TimedStatePath& tStatePath, Q targetQ, double maxGraspTime);
	void simulateTrajectory(State& state, TimedStatePath& tStatePath, Q gripperQ, rw::trajectory::BlendedTrajectory<rw::math::Q> trajectory, double epsilon, rws::RobWorkStudio* rws);

	double getSimTime(){
		return _simulator->getTime();
	}

	double getSimProgress(){
		double progress;
		_progressMutex.lock();
		progress = _progress;
		_progressMutex.unlock();
		return progress;
	}

	void setBodyDynamicsEnabled(Body::Ptr body, bool enabled){
		_simulator->setDynamicsEnabled(body, enabled);
	}

private:
	const rw::common::Ptr<rwsim::dynamics::DynamicWorkCell> _dwc;
	const WorkCell::Ptr _wc;
	const std::string _engineID;
	double _dt;
	bool _debug;
	double _maxSimTime;
	PhysicsEngine::Ptr _pe;
	DynamicSimulator::Ptr _simulator;

	double _progress;
	boost::mutex _progressMutex;

	void setSimProgress(double simTime){
		_progressMutex.lock();
		_progress = simTime/(_maxSimTime*_dt);
		_progressMutex.unlock();
	}
};


#endif /* PICKANDPLACESIMULATOR_H_ */
